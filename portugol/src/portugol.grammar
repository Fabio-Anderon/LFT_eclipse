/*Autor: Anderson Nunes
      Fabio Nascimento
*/

Package portugol;

Helpers

            //ascii_char = [32 .. 127];
            all_char = [0..0xffff];

      //letras e digitos
            
            letras_minus = ['a'..'z'] ; 
            letras_maius = ['A'..'Z'] ;
            digitos = ['0'..'9'] ;
            sublinhado = '_' ;
            aspas_simples = 39;
            //aspas = 34 | 39;
            barraestrela = '/*';
            barrainvert = 92;


      //caracteres nao impressos
            tab = 9;    //horizontal tab
            cr = 13;    //carriage return
            lf = 10;    //line feed
            eol = cr lf| cr | lf ;         
            branco = ' ';

States

      normal, comentario;

Tokens
      //palavras reservadas               
    
      {normal} programa = 'programa' ;             
      {normal} inicio = 'inicio' ;
      {normal} fim = 'fim.' ;
      {normal} const = 'const';
      {normal} var = 'var' ;                             
      {normal} escreva = 'escreva' ;
      {normal} leia = 'leia' ;
      {normal} inteiro = 'inteiro' ;
      {normal} real = 'real' ;
      {normal} caractere = 'caractere' ;
      // {normal} boolean = 'boolean' ;
      //--------------------------------------------
      //if then
      {normal} se = 'se' ;
      {normal} entao = 'entao';
      {normal} fim_se = 'fim'branco'se' ;
      //case 
      {normal} avalie = 'avalie';
      {normal} caso = 'caso'; 
      {normal} fim_avalie = 'fim'branco'avalie' ;
 
      {normal} senao = 'senao'; //if e avalie
      {normal} faca = 'faca'; // enquanto e para
      {normal} ate = 'ate';  // repita e para

      //while
      {normal} enquanto = 'enquanto';
      {normal} fim_enquanto = 'fim'branco'enquanto' ;
 
      {normal} repita = 'repita' ;
      //for
      {normal} para = 'para'; 
      {normal} de = 'de';
      {normal} passo = 'passo';
      {normal} pare = 'pare';
      {normal} continue = 'continue';
      {normal} fim_para = 'fim'branco'para' ;
      //--------------------------------
      //simbolos aritmeticos
      {normal} mais = '+' ;
      {normal} menos = '-' ;
      {normal} produto = '*' ;
      {normal} divisao = '/' ; 
      {normal} atribuicao = '<-' ;

      //simbolos separadores
      {normal} virgula = ',' ;
      {normal} dois_pts = ':' ;
      {normal} pt_virg = ';' ;
      //{normal} pt = '.' ;
      {normal} abre_parantes = '(' ;
      {normal} fecha_parentes = ')' ;
      //{normal} abre_chave = '{';
      //{normal} fecha_chave = '}';
      {normal} abre_colchete = '[' ;
      {normal} fecha_colchete = ']' ;
      
      //simbolos booleanos
      {normal} xor = 'xor' ;
      {normal} ou = 'ou' ;
      {normal} nao = 'nao' ;
      {normal} e = 'e' ;
      {normal} igual = '=' ;
      {normal} diferente = '<>' ;
      {normal} maior = '>' ;
      {normal} menor = '<' ;     
      {normal} maior_igual = '>=' ;
      {normal} menor_igual = '<=' ;


      //Identificadores
      {normal} identificador = (sublinhado | letras_minus | letras_maius)(letras_minus | letras_maius | digitos | sublinhado)*;

      //Numeros
      {normal} num_int = digitos+;
      {normal} num_real = digitos+','digitos+;

       //string
      {normal} string = aspas_simples [[all_char - [lf + cr]] - [aspas_simples + barrainvert]]* 
                        (barrainvert+ aspas_simples? [[all_char - [lf + cr]] - [aspas_simples + barrainvert]]*)* aspas_simples;

      //all_espaco
      {normal} all_espaco = (branco | tab | eol )+ ;

      //Comentarios
      {normal} coment_linha = '//' [all_char - [lf + cr]]*;
      //comentario Aninhado
      {normal->comentario, comentario} coment_aninhado = barraestrela;
      {comentario} coment_escopo = [all_char - ['*' + '/']]*;
      {comentario} coment_estrela = '*';
      {comentario} coment_barra = '/';
      {comentario} coment_fim = '*/';
        

Ignored Tokens
      all_espaco, coment_linha, coment_aninhado, coment_estrela, coment_barra, coment_fim;

Productions

//Cabeçalho
programa = T.programa identificador inicio declaracao* comando* fim ;

//Declaração
declaracao = {variavel} tipo dois_pts decl_var* variavel pt_virg |
       {const}const identificador valor pt_virg;  
decl_var = variavel virgula;
tipo = {real}real | {int}inteiro | {char}caractere;
variavel = {id}identificador | {vetor}identificador abre_colchete num_int fecha_colchete;
valor = {string}string | {num_int}num_int | {num_real}num_real; 

//Corpo de comando
comando = {atribuicao} variavel atribuicao exp pt_virg
| {leia} leia abre_parantes decl_var* variavel fecha_parentes pt_virg
| {escreva_exp} escreva abre_parantes exp_virgula* exp fecha_parentes pt_virg
| {escreva_exp_logica} escreva abre_parantes exp_logica_virgula* exp_logica fecha_parentes pt_virg
| {se} se abre_parantes exp_logica fecha_parentes entao comando+ else_parte? fim_se pt_virg
| {avalie} avalie abre_parantes exp fecha_parentes caso_opcao* padrao? fim_avalie pt_virg
| {enquanto} enquanto abre_parantes exp_logica fecha_parentes faca comando+ fim_enquanto pt_virg
| {repita} repita comando+ ate abre_parantes exp_logica fecha_parentes pt_virg
| {para} para variavel de i_para P.passo? ate n_para faca comando+ fim_para pt_virg;

//Não terminais utilizados no corpo de comandos
exp_virgula = exp virgula;  
exp_logica_virgula = exp_logica virgula;    
else_parte = senao comando+;
caso_opcao = caso valor dois_pts comando+;   
padrao  = senao dois_pts comando+;
passo = T.passo num_int;
i_para = num_int; 
n_para = num_int;

//Expressões
exp = {menos_exp} menos exp | 
             {soma}termo soma_exp_termo*;
termo = {produto}fator mult_fator* ;
fator = {exp_parentes} abre_parantes exp fecha_parentes |  
        {variavel}variavel | 
        {valor}valor;

soma = {mais}mais | {menos}menos;
mult = {produto}produto | {divisao}divisao;

soma_exp_termo = soma termo;
mult_fator = mult fator;


//Menor Precedência
exp_logica = {xor}exp_logica xor exp_ou | {exp_ou}exp_ou;
exp_ou = {ou}exp_ou ou exp_e | {exp_e} exp_e;
exp_e =  {e} exp_e e exp_igual | {exp_igual} exp_igual;
//Permite (a==b) = (b==c) || a = b; Mas não permite a == b == c
exp_igual = [esquerda]: exp igual_diferente [direita]: exp | {exp_mult_igual} exp_mult_igual | {exp_comparacao} exp_comparacao;
exp_mult_igual = [esquerda]: exp_parentes igual_diferente [direita]: exp_parentes;

exp_comparacao = [esquerda]: exp op_comparar [direita]: exp | {exp_nao} exp_nao;
exp_nao = {nao_exp_parentes}nao exp_parentes | {exp_parentes}exp_parentes;
exp_parentes = abre_parantes exp_logica fecha_parentes;

igual_diferente = {igual} igual | {diferente} diferente;
op_comparar = {maior}maior | 
      {menor}menor | 
      {maior_igual}maior_igual |
      {menor_igual}menor_igual ; 


/*
exp : valor
| var
| '(' exp ')'
| '-' exp
| exp '+' exp
| exp '-' exp
| exp '*' exp
| exp '/' exp
| exp-logica


exp-logica: exp '=' exp
| exp '<>' exp
| exp '<=' exp
| exp '>=' exp
| exp '<' exp
| exp '>' exp
| 'nao' exp-logica
| exp-logica 'e' exp-logica
| exp-logica 'ou' exp-logica
| exp-logica 'xor' exp-logica






  // ===== tentativa 3
exp = ex_comparacao opex_comparacao*;
ex_comparacao = ex_xor opex_xor*;
ex_xor = ex_ou_soma opex_ou_soma*;
ex_ou_soma = ex_e_mult opex_e_mult*;
ex_e_mult = ex_nao opex_nao*;
exp_caso_base = {exp_parentes}abre_parantes exp fecha_parentes | 
                  {variavel}variavel  |
                  {valor}valor;


opex_comparacao = op1 ex_comparacao;
opex_xor = op2 ex_xor;
opex_ou_soma = op3 ex_ou_soma;
opex_e_mult = op4 ex_e_mult;
opex_nao = op5 exp_caso_base;


op1 = {maior}maior | 
      {menor}menor | 
      {igual}igual | 
      {diferente}diferente |
      {maior_igual}maior_igual |
      {menor_igual}menor_igual ;
op2 = xor;
op3 = {mais}mais | {menos}menos | {ou}ou;
op4 = {produto}produto | {divisao}divisao  | {e}e;
op5 = nao;

//=======================================================


   */
